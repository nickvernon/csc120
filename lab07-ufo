; Orbelin Palacios & Nick Vernon

(require 2htdp/image)
(require 2htdp/universe)

;                                                                          
;                                                                          
;                                                                          
;                                                                          
;     ;;;;                                                                 
;    ;   ;                           ;                       ;             
;   ;        ;;;;   ;; ;;    ;;;;;  ;;;;;    ;;;;   ;; ;;   ;;;;;    ;;;;; 
;   ;       ;    ;   ;;  ;  ;    ;   ;      ;    ;   ;;  ;   ;      ;    ; 
;   ;       ;    ;   ;   ;   ;;;;    ;       ;;;;;   ;   ;   ;       ;;;;  
;   ;       ;    ;   ;   ;       ;   ;      ;    ;   ;   ;   ;           ; 
;    ;   ;  ;    ;   ;   ;  ;    ;   ;   ;  ;   ;;   ;   ;   ;   ;  ;    ; 
;     ;;;    ;;;;   ;;; ;;; ;;;;;     ;;;    ;;; ;; ;;; ;;;   ;;;   ;;;;;  
;                                                                          
;                                                                          
;                                                                          
;                                                                          

(define WIDTH 500)
(define HEIGHT 500)
(define BACKGROUND (empty-scene WIDTH HEIGHT "lightblue"))
(define BASE-IMG (rectangle 50 10 "solid" "darkgreen"))
(define SHOT-IMG (circle 2 "solid" "red"))
(define TARGET-IMG (overlay (circle 3 "solid" "lightblack")
                            (rectangle 1 14 "solid" "lightblack")
                            (rectangle 14 1 "solid" "lightblack")
                            (circle 7 "outline" "lightblack")))
(define UFO-IMG (overlay
                 (above (beside (ellipse 5 3 "solid" "red")
                                (ellipse 5 3 "solid" "red")
                                (ellipse 5 3 "solid" "red"))
                        (rectangle 0 10 "solid" "white"))
                 (ellipse 30 7 "solid" (make-color 200 0 200 150))
                 (circle 10 "solid" "green")))


;                                                                                          
;                                                                                          
;                                                                                          
;                                                                                          
;   ;;;;               ;;;     ;               ;               ;                           
;    ;  ;             ;                              ;                                     
;    ;   ;   ;;;;   ;;;;;;   ;;;    ;; ;;    ;;;    ;;;;;    ;;;     ;;;;   ;; ;;    ;;;;; 
;    ;   ;  ;    ;    ;        ;     ;;  ;     ;     ;         ;    ;    ;   ;;  ;  ;    ; 
;    ;   ;  ;;;;;;    ;        ;     ;   ;     ;     ;         ;    ;    ;   ;   ;   ;;;;  
;    ;   ;  ;         ;        ;     ;   ;     ;     ;         ;    ;    ;   ;   ;       ; 
;    ;  ;   ;         ;        ;     ;   ;     ;     ;   ;     ;    ;    ;   ;   ;  ;    ; 
;   ;;;;     ;;;;;  ;;;;;;   ;;;;;  ;;; ;;;  ;;;;;    ;;;    ;;;;;   ;;;;   ;;; ;;; ;;;;;  
;                                                                                          
;                                                                                          
;                                                                                          
;                                                                                          


;; A MouseEvent is either:
;;  - "move"
;;  - "drag"
;;  - "button-down"
;;  - or some other string
;; interp. represents a user's action with the mouse in the window.

#;  ; template
(define (mouse-event-func a-me)
  (cond
    [(mouse=? "move" a-me) ...]
    [(mouse=? "drag" a-me) ...]
    [(mouse=? "button-down" a-me) ...]
    [else ...]))


;; A KeyEvent is either:
;;   - "left"
;;   - "right"
;;   - "down"
;;   - "w"
;;   - "d"
;;   - "s"
;;   - " "
;;   - or some other string
;; interp. represents a user's action with the keyboard

#;  ; template
(define (key-event-func a-ke)
  (cond
    [(key=? "left" a-ke) ...]
    [(key=? "right" a-ke) ...]
    [(key=? "down" a-ke) ...]
    [(key=? "w" a-ke) ...]
    [(key=? "d" a-ke) ...]
    [(key=? "s" a-ke) ...]
    [(key=? " " a-ke) ...]
    [else ...]))


;; A Direction is either:
;;   - "left"
;;   - "right"
;;   - "stopped"
;;  interp. the movement direction of the player's base station

(define (direction-func a-direction)
  (cond
    [(string=? "left" a-direction) ...]
    [(string=? "right" a-direction) ...]
    [(string=? "stopped" a-direction) ...]
    ))


(define-struct base (x dir))
;; A Base is (make-base Number Direction)
;; interp. the player's base station, with the current x-position
;; where it appears (always at a fixed Y coordinate near the bottom
;; of the window) and its current direction of movement.

(define BASE1 (make-base 0 "left"))
(define BASE2 (make-base 30 "right"))
(define BASE3 (make-base 220 "stopped"))

#;  ; template
(define (base-func a-base)
  (... (base-x a-base)
       (direction-func (base-dir a-base)) ...
       ))


(define-struct shot (loc vel))
;; A Shot is (make-shot Posn Posn)
;; interp. represents a shot fired from the player's base
;; in particular, (make-shot (make-posn x y) (make-posn vx vy)) represents
;; a shot that is currently at location (x, y) on the screen, and whose
;; location changes with each tick of the clock by adding (vx, vy) to the
;; current values.

(define SHOT1 (make-shot (make-posn 200 250) (make-posn 3 3)))
(define SHOT2 (make-shot (make-posn 0 0) (make-posn 3 3)))

#;  ; template
(define (shot-func a-shot)
  (... (posn-func (shot-loc a-shot))
       (posn-func (shot-vel a-shot))...))

;; A List-of-shots (or, LOS) is either:
;;   - empty
;;   - (cons Shot LOS)
;; interp. a list of existing shots

; examples
(define SHOTS1 (cons SHOT1 (cons SHOT2 empty)))
(define SHOTS2 (cons (make-shot (make-posn 265 485) (make-posn 0 3)) empty))
(define SHOTS3 empty)

#;  ; template
(define (los-func a-los ...)
  (cond
    [(empty? a-los) ...]
    [(cons? a-los) (... (shot-func (first a-los)) ...
                        (los-func (rest a-los) ...))]))



;; A List-of-posns (or, LOP) is either:
;;   - empty
;;   - (cons Posn LOP)
;; interp. a list of posns for UFOs

; examples
(define UFO1 (cons (make-posn 256 125) (cons (make-posn 148 269) empty)))
(define UFO2 (cons (make-posn 154 366) (cons (make-posn 0 0) empty)))
(define UFO3 empty)

#;  ; template
(define (lop-func a-lop...)
  (cond
    [(empty? a-lop) ...]
    [(cons? a-lop) (... (posn-func (first a-lop))
                        (lop-func (rest a-lop))...)]))


(define-struct udge (base target shots ufos))
;; An UDGE (short for "Ufo Defense GamE") is
;;    (make-udge Base Posn List-of-shots List-of-posns)
;; interp. represents the complete state of the game world with the
;;  player's base, the current target (based on mouse movement), a
;;  list of fired shots, and a list of locations of attacking UFOs.

; an example game state
(define START-GAME (make-udge (make-base (/ WIDTH 2) "stopped")
                              (make-posn (/ WIDTH 2) (/ HEIGHT 2))
                              empty empty))

#;  ; template
(define (udge-func an-udge)
  (... (base-func (udge-base an-udge))   ...
   ... (posn-func (udge-target an-udge)) ...
   ... (los-func (udge-shots an-udge))   ...
   ... (lop-func (udge-ufos an-udge))    ...))





;                                                                          
;                                                                          
;                                                                          
;                                                                          
;   ;;;;;;                                     ;                           
;    ;   ;                           ;                                     
;    ; ;    ;;  ;;  ;; ;;    ;;; ;  ;;;;;    ;;;     ;;;;   ;; ;;    ;;;;; 
;    ;;;     ;   ;   ;;  ;  ;   ;;   ;         ;    ;    ;   ;;  ;  ;    ; 
;    ; ;     ;   ;   ;   ;  ;        ;         ;    ;    ;   ;   ;   ;;;;  
;    ;       ;   ;   ;   ;  ;        ;         ;    ;    ;   ;   ;       ; 
;    ;       ;  ;;   ;   ;  ;    ;   ;   ;     ;    ;    ;   ;   ;  ;    ; 
;   ;;;       ;; ;; ;;; ;;;  ;;;;     ;;;    ;;;;;   ;;;;   ;;; ;;; ;;;;;  
;                                                                          
;                                                                          
;                                                                          
;                           

;; render-world : UDGE -> Image
;; consumes a world datum and produces the corresponding image of the current
;; state of the game

(check-expect (render-world START-GAME) (place-image TARGET-IMG
                                                     (/ WIDTH 2) (/ HEIGHT 2)
                                                     (place-image BASE-IMG
                                                                  (/ WIDTH 2) 475
                                                                  BACKGROUND)))
(check-expect (render-world (make-udge (make-base 125 "left")
                                       (make-posn 360 120)
                                       SHOTS1 UFO2))
              (place-image UFO-IMG
                           0 0
                           (place-image UFO-IMG
                                        154 366
                                        (place-image SHOT-IMG
                                                     0 0
                                                     (place-image SHOT-IMG
                                                                  200 250
                                                                  (place-image TARGET-IMG
                                                                               360 120
                                                                               (place-image BASE-IMG
                                                                                            125 475
                                                                                            BACKGROUND)))))))
(check-expect (render-world (make-udge (make-base 154 "right")
                                       (make-posn 360 120)
                                       SHOTS1 UFO1))
              (place-image UFO-IMG
                           148 269
                           (place-image UFO-IMG
                                        256 125
                                        (place-image SHOT-IMG
                                                     0 0
                                                     (place-image SHOT-IMG
                                                                  200 250
                                                                  (place-image TARGET-IMG
                                                                               360 120
                                                                               (place-image BASE-IMG
                                                                                            154 475
                                                                                            BACKGROUND)))))))


(define (render-world an-udge) 
  (place-ufos (udge-ufos an-udge)
              (place-shots (udge-shots an-udge)
                           (place-image BASE-IMG
                                        (base-x (udge-base an-udge)) 475
                                        (place-image TARGET-IMG
                                                     (posn-x (udge-target an-udge))
                                                     (posn-y (udge-target an-udge))
                                                     BACKGROUND)))))
                           
                                          

;; place-shots : LOS Image -> Image
;; consumes a list of shots and produces an image of the shots on a background


(check-expect (place-shots empty BACKGROUND) BACKGROUND)
(check-expect (place-shots (list (make-shot (make-posn 200 203) (make-posn 0 -10))
                                 (make-shot (make-posn 120 150) (make-posn 0 -10))
                                 (make-shot (make-posn 36 49) (make-posn 0 -10)))
                           BACKGROUND)
              (place-image SHOT-IMG
                           36 49
                           (place-image SHOT-IMG
                                        120 150
                                        (place-image SHOT-IMG
                                                     200 203
                                                     BACKGROUND))))
(check-expect (place-shots (list (make-shot (make-posn 43 290) (make-posn 0 -10))
                                 (make-shot (make-posn 20 299) (make-posn 0 -10))
                                 (make-shot (make-posn 300 103) (make-posn 0 -10)))
                           BACKGROUND)
              (place-image SHOT-IMG
                           300 103
                           (place-image SHOT-IMG
                                        20 299
                                        (place-image SHOT-IMG
                                                     43 290
                                                     BACKGROUND))))

(define (place-shots a-los an-image)
  (cond
    [(empty? a-los) an-image]
    [(cons? a-los) (place-image SHOT-IMG
                                (posn-x (shot-loc (first a-los)))
                                (posn-y (shot-loc (first a-los)))
                                (place-shots (rest a-los) an-image)
                                )]))


;; place-ufos : LOP Image -> Image
;; consumes a list of ufos and produces an image of the ufos on a background

(check-expect (place-ufos empty BACKGROUND) BACKGROUND)
(check-expect (place-ufos UFO2 BACKGROUND)
              (place-image UFO-IMG
                           154 366
                           (place-image UFO-IMG
                                        0 0
                                        BACKGROUND)))
(check-expect (place-ufos UFO2 BACKGROUND)
              (place-image UFO-IMG
                           154 366
                           (place-image UFO-IMG
                                        0 0
                                        BACKGROUND)))
(check-expect (place-ufos UFO1 BACKGROUND)
              (place-image UFO-IMG
                           256 125
                           (place-image UFO-IMG
                                        148 269
                                        BACKGROUND)))

(define (place-ufos a-lop an-image)
  (cond
    [(empty? a-lop) an-image]
    [(cons? a-lop) (place-image UFO-IMG
                                (posn-x (first a-lop))
                                (posn-y (first a-lop))
                                (place-ufos (rest a-lop) an-image))]))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; update-world : UDGE -> UDGE
;; consumes a world and produces a world reflecting what happens each time the clock "ticks"


(define (update-world an-udge)
  (make-udge (update-base (udge-base an-udge))
             (udge-target an-udge)
             (filter on-screen? (update-shots an-udge (udge-shots an-udge)))
             (update-ufos an-udge (produce-ufos (udge-ufos an-udge)))
                            ))
    

;; update-base : Base -> Base
;; consumes a base and produces a new base with a new x-coordinate depending on number of ticks

(check-expect (update-base (make-base 264 "right")) (make-base 267 "right"))
(check-expect (update-base (make-base 350 "left")) (make-base 347 "left"))
(check-expect (update-base (make-base 250 "stopped")) (make-base 250 "stopped"))
(check-expect (update-base (make-base (/ (image-width BASE-IMG) 2) "left"))
              (make-base (/ (image-width BASE-IMG) 2) "left"))
(check-expect (update-base (make-base (- 500 (/ (image-width BASE-IMG) 2)) "right"))
              (make-base (- 500 (/ (image-width BASE-IMG) 2)) "right"))

(define (update-base a-base)
  (cond
    [(string=? (base-dir a-base) "left")(if (= (base-x a-base) (/ (image-width BASE-IMG) 2))
                                            (make-base (/ (image-width BASE-IMG) 2) "left")
                                            (make-base (- (base-x a-base) 3) "left"))]
    [(string=? (base-dir a-base) "right")(if (= (base-x a-base) (- 500 (/ (image-width BASE-IMG) 2)))
                                             (make-base (- 500 (/ (image-width BASE-IMG) 2)) "right")
                                             (make-base (+ (base-x a-base) 3) "right"))]
    [(string=? (base-dir a-base) "stopped")(make-base (base-x a-base) "stopped")]))



;; update-shots : UDGE LOS -> LOS
;; consumes a ufos from an udge and a list-of-shots and produces a new list-of-shots with updated coordinates

(check-expect (update-shots START-GAME empty) empty)
(check-expect (update-shots (make-udge (make-base 250 "stopped")(make-posn 250 250) empty UFO2) (list (make-shot (make-posn 154 366)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 20 20)(make-posn 0 0))))
              (list (make-shot (make-posn 20 20)(make-posn 0 0))))
(check-expect (update-shots (make-udge (make-base 250 "stopped")(make-posn 250 250) empty UFO2) (list (make-shot (make-posn 300 366)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 20 20)(make-posn 0 0))))
              (list (make-shot (make-posn 300 366)(make-posn 0 0))
                    (make-shot (make-posn 20 20)(make-posn 0 0))))
(check-expect (update-shots (make-udge (make-base 250 "stopped")(make-posn 250 250) empty UFO2) (list (make-shot (make-posn 300 366)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 20 20)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 220 210)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 20 320)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 420 240)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 250 270)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 420 320)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 200 220)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 210 201)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 260 208)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 350 420)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 260 120)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 270 0)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 420 3)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 120 320)(make-posn 0 0))
                                                                                                      (make-shot (make-posn 220 230)(make-posn 0 0))))
              (list (make-shot (make-posn 20 20)(make-posn 0 0))
                    (make-shot (make-posn 220 210)(make-posn 0 0))
                    (make-shot (make-posn 20 320)(make-posn 0 0))
                    (make-shot (make-posn 420 240)(make-posn 0 0))
                    (make-shot (make-posn 250 270)(make-posn 0 0))
                    (make-shot (make-posn 420 320)(make-posn 0 0))
                    (make-shot (make-posn 200 220)(make-posn 0 0))
                    (make-shot (make-posn 210 201)(make-posn 0 0))
                    (make-shot (make-posn 260 208)(make-posn 0 0))
                    (make-shot (make-posn 350 420)(make-posn 0 0))
                    (make-shot (make-posn 260 120)(make-posn 0 0))
                    (make-shot (make-posn 270 0)(make-posn 0 0))
                    (make-shot (make-posn 420 3)(make-posn 0 0))
                    (make-shot (make-posn 120 320)(make-posn 0 0))
                    (make-shot (make-posn 220 230)(make-posn 0 0))))

(define (update-shots an-udge a-los)
  (cond
    [(empty? a-los) empty]
    [(cons? a-los) (if (hit-shot? (first a-los) (udge-ufos an-udge))
                       (update-shots an-udge (rest a-los))
                       (if (<= (length a-los) 15)
                           (cons (make-shot (posn-add (shot-loc (first a-los)) (shot-vel (first a-los))) (shot-vel (first a-los)))
                                 (update-shots an-udge (rest a-los)))
                           (update-shots an-udge (rest a-los))))]
    ))

;; hit-shot? : Shot LOP -> Boolean
;; produces false if the given shot is within 20 pixels of a ufo

(check-expect (hit-shot? (make-shot (make-posn 250 250) (make-posn 0 -10))
                         empty)
              false)
(check-expect (hit-shot? (make-shot (make-posn 250 250) (make-posn 0 -10))
                         (list (make-posn 0 0)
                               (make-posn 100 100)
                               (make-posn 250 250)))
              true)
(check-expect (hit-shot? (make-shot (make-posn 250 250) (make-posn 0 -10))
                         (list (make-posn 0 0)
                               (make-posn 100 100)
                               (make-posn 400 400)))
              false)

(define (hit-shot? a-shot a-lop)
  (cond
    [(empty? a-lop) false]
    [(cons? a-lop) (if (<= (posn-distance (shot-loc a-shot) (first a-lop)) 20)
                       true
                       (hit-shot? a-shot (rest a-lop)))]))
    


;; posn-distance : Posn Posn -> Number
;; produces the distance between the given posns

(check-expect (posn-distance (make-posn 0 0) (make-posn 0 10)) 10)
(check-expect (posn-distance (make-posn 0 0) (make-posn 20 0)) 20)
(check-expect (posn-distance (make-posn 4 5) (make-posn 7 1)) 5)
(check-expect (posn-distance (make-posn 16 18) (make-posn 16 15)) 3)

(define (posn-distance p1 p2)
  (sqrt (+ (sqr (- (posn-x p1) (posn-x p2)))
           (sqr (- (posn-y p1) (posn-y p2))))))

;; posn-add : Posn Posn -> Posn
;; produce the result of adding the components of the two given posns

(check-expect (posn-add (make-posn 3 4) (make-posn 5 6))
              (make-posn 8 10))
(check-expect (posn-add (make-posn 0 4) (make-posn 3 -6))
              (make-posn 3 -2))
(check-expect (posn-add (make-posn 15 -2) (make-posn 4 2))
              (make-posn 19 0))
(check-expect (posn-add (make-posn 203 -120) (make-posn 23 50))
              (make-posn 226 -70))

(define (posn-add a-posn b-posn)
  (make-posn (+ (posn-x a-posn) (posn-x b-posn))
             (+ (posn-y a-posn) (posn-y b-posn))))



;; on-screen? : Shot -> Boolean
;; produces true if the shot is still within the given boundaries

(check-expect (on-screen? (make-shot (make-posn 500 250) (make-posn 0 -10)))true)
(check-expect (on-screen? (make-shot (make-posn 504 250) (make-posn 0 -10)))false)
(check-expect (on-screen? (make-shot (make-posn 50 504) (make-posn 0 -10)))false)
(check-expect (on-screen? (make-shot (make-posn -10 250) (make-posn 0 -10)))false)
(check-expect (on-screen? (make-shot (make-posn 250 -1) (make-posn 0 -10)))false)

(define (on-screen? a-shot)
  (and (and (<= (posn-x (shot-loc a-shot)) 500)
            (>= (posn-x (shot-loc a-shot)) 0))
       (and (<= (posn-y (shot-loc a-shot)) 500)
            (>= (posn-y (shot-loc a-shot)) 0))))




;; produce-ufos : LOP -> LOP
;; consumes a list-of-posns for ufos and adds a new ufo with 3% probability
;;          on every tick if there are not already 20 ufos

;; Wasn't sure how to make check-expects for this function since there is only a 3% chance of this being true and the posn-x 
;; value would be a random number.

(check-expect (produce-ufos (list (make-posn 0 0) (make-posn 250 250)))
              (list (make-posn 0 0) (make-posn 250 250)))

(define (produce-ufos a-lop)
  (if (and (<= (random-between 0 101) 3) (<= (length a-lop) 20))
      (cons (make-posn (random-between 50 (- WIDTH 49)) 0) a-lop)
      a-lop))



;; random-between : Number Number -> Number
;; produce a random number between a and b, inclusive of a, not of b

(check-random (random-between 10 100) (+ 10 (random 90)))
(check-random (random-between 0 10) (random 10))
(check-random (random-between 15 60) (+ 15 (random 45)))

(define (random-between a b)
  (+ a (random (max 1 (abs (- b a))))))



;; update-ufos : LOP -> LOP
;; consumes a list-of-posns and produces a new list-of-posns with updated
;;          ufos

(check-expect (update-ufos START-GAME empty) empty)
(check-expect (update-ufos START-GAME (list (make-posn 0 0)
                                            (make-posn 250 250)))
              (list (make-posn 0 4)
                    (make-posn 250 254)))
(check-expect (update-ufos (make-udge (make-base 250 "stopped") (make-posn 250 250)(list SHOT1) empty) (list (make-posn 200 250)
                                                                                                             (make-posn 20 20)))
              (list (make-posn 20 24)))

(define (update-ufos an-udge a-lop)
  (cond
    [(empty? a-lop) empty]
    [(cons? a-lop) (if (hit-ufo? (first a-lop) (udge-shots an-udge))
                       (update-ufos an-udge (rest a-lop))
                       (cons (posn-add (make-posn (posn-x (first a-lop))
                                              (posn-y (first a-lop)))
                                       (make-posn 0 4))
                             (update-ufos an-udge (rest a-lop))))]))


;; hit-ufo? : UFO LOS -> Boolean
;; produces false if the given ufo is within 20 pixels of a shot

(check-expect (hit-ufo? (make-posn 200 200) (list (make-shot (make-posn 200 200) (make-posn 0 0))
                                                   (make-shot (make-posn 0 200) (make-posn 0 0))
                                                   (make-shot (make-posn 200 0) (make-posn 0 0))
                                                   (make-shot (make-posn 0 0) (make-posn 0 0))))
              true)
(check-expect (hit-ufo? (make-posn 200 200) (list (make-shot (make-posn 0 1) (make-posn 0 0))
                                                   (make-shot (make-posn 0 200) (make-posn 0 0))
                                                   (make-shot (make-posn 200 0) (make-posn 0 0))
                                                   (make-shot (make-posn 0 0) (make-posn 0 0))))
              false)
(check-expect (hit-ufo? (make-posn 200 200) (list (make-shot (make-posn 0 0) (make-posn 0 0))
                                                   (make-shot (make-posn 0 200) (make-posn 0 0))
                                                   (make-shot (make-posn 200 200) (make-posn 0 0))
                                                   (make-shot (make-posn 0 0) (make-posn 0 0))))
              true)

(define (hit-ufo? a-ufo a-los)
  (cond
    [(empty? a-los) false]
    [(cons? a-los) (if (<= (posn-distance a-ufo (shot-loc (first a-los))) 20)
                             true
                             (hit-ufo? a-ufo (rest a-los)))]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     
;; handle-key : Udge KeyEvent -> Udge
;; consumes an UDGE and a key event and updates the movement direction
;;  of the base

(check-expect (handle-key (make-udge (make-base 20 "stopped") (make-posn 20 20) empty empty) "left") 
              (make-udge (make-base 20 "left") (make-posn 20 20) empty empty))
(check-expect (handle-key (make-udge (make-base 20 "stopped") (make-posn 20 20) empty empty) "right") 
              (make-udge (make-base 20 "right") (make-posn 20 20) empty empty))
(check-expect (handle-key (make-udge (make-base 20 "right") (make-posn 20 20) empty empty) "down") 
              (make-udge (make-base 20 "right") (make-posn 20 20) (list (make-shot (make-posn 20 475) (make-posn 0 -10))) empty))
(check-expect (handle-key (make-udge (make-base 20 "stopped") (make-posn 20 20) empty empty) "a") 
              (make-udge (make-base 20 "left") (make-posn 20 20) empty empty))
(check-expect (handle-key (make-udge (make-base 20 "stopped") (make-posn 20 20) empty empty) "d") 
              (make-udge (make-base 20 "right") (make-posn 20 20) empty empty))
(check-expect (handle-key (make-udge (make-base 20 "right") (make-posn 20 20) empty empty) "s") 
              (make-udge (make-base 20 "right") (make-posn 20 20) (list (make-shot (make-posn 20 475) (make-posn 0 -10))) empty))
(check-expect (handle-key (make-udge (make-base 20 "right") (make-posn 20 20) empty empty) " ") 
              (make-udge (make-base 20 "stopped") (make-posn 20 20) empty empty))
(check-expect (handle-key (make-udge (make-base 20 "right") (make-posn 20 20) empty empty) "\t") 
              (make-udge (make-base 20 "right") (make-posn 20 20) empty empty))



(define (handle-key an-udge a-ke)
  (cond
    [(key=? "left" a-ke) (make-udge (make-base (base-x (udge-base an-udge)) "left") 
                                    (udge-target an-udge)
                                    (udge-shots an-udge)
                                    (udge-ufos an-udge))]
    [(key=? "right" a-ke) (make-udge (make-base (base-x (udge-base an-udge)) "right") 
                                    (udge-target an-udge)
                                    (udge-shots an-udge)
                                    (udge-ufos an-udge))]
    [(key=? "down" a-ke) (make-udge (make-base (base-x (udge-base an-udge)) (base-dir (udge-base an-udge)))
                                    (udge-target an-udge)
                                    (cons (make-shot (make-posn (base-x (udge-base an-udge)) 475)
                                                     (velocity-to (make-posn (base-x (udge-base an-udge)) 475)
                                                                  (udge-target an-udge)
                                                                  10))
                                          (udge-shots an-udge))
                                    (udge-ufos an-udge))]
    [(key=? "a" a-ke) (make-udge (make-base (base-x (udge-base an-udge)) "left") 
                                    (udge-target an-udge)
                                    (udge-shots an-udge)
                                    (udge-ufos an-udge))]
    [(key=? "d" a-ke) (make-udge (make-base (base-x (udge-base an-udge)) "right") 
                                    (udge-target an-udge)
                                    (udge-shots an-udge)
                                    (udge-ufos an-udge))]
    [(key=? "s" a-ke) (make-udge (make-base (base-x (udge-base an-udge)) (base-dir (udge-base an-udge)))
                                    (udge-target an-udge)
                                    (cons (make-shot (make-posn (base-x (udge-base an-udge)) 475)
                                                     (velocity-to (make-posn (base-x (udge-base an-udge)) 475)
                                                                  (udge-target an-udge)
                                                                  10))
                                          (udge-shots an-udge))
                                    (udge-ufos an-udge))]
    [(key=? " " a-ke) (make-udge (make-base (base-x (udge-base an-udge)) "stopped") 
                                 (udge-target an-udge)
                                 (udge-shots an-udge)
                                 (udge-ufos an-udge))]
    [else an-udge]))




;; handle-mouse : Udge Number Number MouseEvent -> Udge
;; consumes an UDGE and a mouse event along with x,y coordinates and produces
;; a new UDGE relfecting changes in the world based on what happened with the
;; mouse

(check-expect (handle-mouse START-GAME 100 100 "move")
              (make-udge (udge-base START-GAME)
                         (make-posn 100 100)
                         empty empty))
(check-expect (handle-mouse START-GAME 300 300 "drag")
              (make-udge (udge-base START-GAME)
                         (make-posn 300 300)
                         empty empty))
(check-expect (handle-mouse START-GAME 250 250 "button-down")
              (make-udge (udge-base START-GAME)
                         (make-posn 250 250)
                         (list (make-shot (make-posn 250 475)
                                          (make-posn 0 -10)))
                         empty))
(check-expect (handle-mouse START-GAME 250 250 "button-up")
              START-GAME)

(define (handle-mouse an-udge num-a num-b a-me)
  (cond
    [(mouse=? "move" a-me) (make-udge (udge-base an-udge)
                                      (make-posn num-a num-b)
                                      (udge-shots an-udge)
                                      (udge-ufos an-udge))]
    [(mouse=? "drag" a-me) (make-udge (udge-base an-udge)
                                      (make-posn num-a num-b)
                                      (udge-shots an-udge)
                                      (udge-ufos an-udge))]
    [(mouse=? "button-down" a-me) (make-udge (udge-base an-udge)
                                             (make-posn num-a num-b)
                                             (cons (make-shot (make-posn (base-x (udge-base an-udge)) 475)
                                                     (velocity-to (make-posn (base-x (udge-base an-udge)) 475)
                                                                  (udge-target an-udge)
                                                                  10))
                                                   (udge-shots an-udge))
                                             (udge-ufos an-udge))]
    [else an-udge]))


;; velocity-to : Posn Posn Number -> Posn
;; produce a velocity vector by splitting the given 'speed' value
;; into x and y components based on the difference between the
;; location and target positions

; the following example says: if you are at location (0, 0) and your
;   target is at (10, 0) and you want to move with a speed of 2 units
;   then your velocity will be 2 units in the x direction, and 0 in 
;   the y direction;  the other examples may be read in the same way
(check-expect (velocity-to (make-posn 0 0) (make-posn 10 0) 2)
              (make-posn 2 0))
(check-expect (velocity-to (make-posn 10 0) (make-posn 10 10) 3)
              (make-posn 0 3))
(check-expect (velocity-to (make-posn 10 10) (make-posn 13 14) 2)
              (make-posn 6/5 8/5))

(define (velocity-to location target speed)
  (make-posn (* speed (/ (- (posn-x target) (posn-x location))
                                        (posn-distance location target)))
             (* speed (/ (- (posn-y target) (posn-y location))
                                        (posn-distance location target)))))



;; game-over? : UDGE -> Boolean
;; Produces true if the game should stop (a UFO reaches the bottom)

(check-expect (game-over? (make-udge (make-base 20 "right")
                                     (make-posn 20 20)
                                     empty
                                     (list (make-posn 200 (- 500 (/ (image-height UFO-IMG) 2))))))
              true)
(check-expect (game-over? (make-udge (make-base 20 "right")
                                     (make-posn 20 20)
                                     empty
                                     (list (make-posn 200 250))))
              false)
(check-expect (game-over? (make-udge (make-base 20 "right")
                                     (make-posn 20 20)
                                     empty
                                     (list (make-posn 200 490))))
              true)
(check-expect (game-over? (make-udge (make-base 20 "right")
                                     (make-posn 20 20)
                                     empty
                                     (list (make-posn 200 488))))
              false)
(check-expect (game-over? START-GAME) false)

(define (game-over? an-udge)
  (cond
    [(empty? (udge-ufos an-udge)) false]
    [(cons? (udge-ufos an-udge)) (reached-bottom? (udge-ufos an-udge))]
    ))

;; reached-bottom? : LOP -> Boolean
;; produces true if a ufo has reached the bottom of the game

(check-expect (reached-bottom? (list (make-posn 250 250)
                                     (make-posn 54 420)))
              false)
(check-expect (reached-bottom? (list (make-posn 500 500)
                                     (make-posn 450 200)))
              true)
(check-expect (reached-bottom? (list (make-posn 500 450)
                                     (make-posn 450 200)))
              false)
(check-expect (reached-bottom? (list (make-posn 200 500)
                                     (make-posn 450 50)))
              true)
(check-expect (reached-bottom? (list (make-posn 230 488)
                                     (make-posn 433 249)))
              false)
(check-expect (reached-bottom? empty) false)

(define (reached-bottom? a-lop)
  (cond
    [(empty? a-lop) false]
    [(cons? a-lop)(if (>= (posn-y (first a-lop)) (- 500 (/ (image-height UFO-IMG) 2)))
                      true
                      (reached-bottom? (rest a-lop)))]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




(define (main an-udge)
  (big-bang an-udge
            (to-draw render-world)
            (on-tick update-world)
            (on-key handle-key)
            (on-mouse handle-mouse)
            (stop-when game-over?)))



