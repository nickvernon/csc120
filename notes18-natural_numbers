
;                                                           
;  Lecture 21
;  Natural Numbers
;   
;  . 
;  
; "The best book on programming for the layman is
;  "Alice in Wonderland"; but that's because it's 
;  the best book on anything for the layman."
;                                -- Alan Perlis (1922-1990)
;  
;  


(require 2htdp/image)

;                                                           
; This week we've looked at programs that solve problems 
; involving arbitrary amounts of information.
; 
; We learned that this requires self-referential data 
; definitions to represent the information.
; 
; We learned that if the self-referential data definitions 
; are well defined we get templates with natural recursions, 
; and that the resulting recursive functions terminate (i.e. 
; they "work").
; 
; Today, we'll look at another example of a data definition
; for a representation of arbitrary sized information, and 
; how much power we wield when we design how to represent 
; information with data.
; 
; ===========================================================
; 
; In particular, we'll look at numbers. Some (not all)
; numbers can be recursively defined...
; 



;                                                           
; NATURAL NUMBERS
; 
; - 0, 1, 2, 3, 4, 5, ....
; - Amenable to processing using recursive functions
; - Basis for number theory (which, in turn, is the basis for
;   everything else - or at least many other things.)
; 
; "God created the natural number, 
;  and all the rest is the work of man." 
;                               Leopold Kronecker (1823-1891)
; 
; "Mathematics is the queen of the sciences and number theory 
;  is the queen of mathematics."
;                            Carl Friedrich Gauss (1777-1855)
; 
;                            
; An insight for defining the natural numbers is that 0 (zero)
; is kind of like 'empty' in that it's the simplest (or 
; smallest) natural number. Then, whenever you have a natural
; number, you can add one more to it to get another one.
; 


;; DATA DEFINITION

; A Nat (short for 'natural number') is one of:
;  - 0
;  - (add1 Nat)
; interp. a natural number is either zero or one larger
;         than another natural number


;                                                           
; What's not new
;   - mixed data, self-referential definition
;   
; What's new
;   - we're using a function instead of a structure, but
;     it works fine - you can think of 'add1' as a 
;     constructor just like 'cons' for lists
; 


;; EXAMPLES

(define zero 0)
(define one (add1 0))
(define four (add1 (add1 (add1 (add1 0)))))
; note:  4   is just a shortcut for 
;            writing (add1 (add1 (add1 (add1 0)))), just like
;      (list ...) is a shortcut for (cons .. (cons .. empty))


;                                                           
; BASIC OPERATIONS WITH Nats
; 
; Constructor
;  - add1 : Nat -> Nat
;  
; Predicates
;  - zero?  : Any -> Boolean
;  - positive? : Any -> Boolean
;  
; Selector
;  - sub1 : Nat -> Nat
; 
; ===========================================================
;  
; Compare the list operations:
; 
;  - (empty? empty)        = true
;  - (cons? (cons f r))    = false
;  - (first (cons f r))    = f
;  - (rest (cons f r))     = r
;  
; to the nat operations:
;  
;  - (zero? 0)             = true
;  - (positive? (add1 n))  = true
;  - (sub1 (add1 n))       = n
;  


(check-expect (sub1 (add1 (add1 (add1 0))))
              (add1 (add1 0)))


;; TEMPLATE

#;
(define (nat-func n)
  (cond
    [(zero? n) (...)]
    [(positive? n)
     (... (nat-func (sub1 n)) ...)]))


;                                                           
; FUNCTIONS ON Nat
; 
; ; boxes : Nat -> Image
; ; produce n nested boxes with dot inside
;   (boxes 0)  produces .
;   (boxes 1)  produces .
;   (boxes 4)  produces .
; 
; 
; ; ! : Nat -> Nat
; ; produces n * n-1 * n-2 ... 1
;   
; ; mul : Nat Nat -> Nat
; ; produces the product of n and m
;   
; ; add : Nat Nat -> Nat
; ; produces the sum of n and m



; boxes : Nat -> Image
; produce n nested boxes with dot inside
(check-expect (boxes 0) (square 1 "outline" "black"))
(check-expect (boxes 1) (overlay (square 10 "outline" "black")
                                 (square 1 "outline" "black")))
(check-expect (boxes 2) (overlay (square 20 "outline" "black")
                                 (square 10 "outline" "black")
                                 (square 1 "outline" "black")))

(define (boxes n)
  (cond
    [(zero? n) (square 1 "outline" "black")]
    [(positive? n)
     (overlay (square (* n 10) "outline" "black")
              (boxes (sub1 n)))]))


; ! : Nat -> Nat
; produces n * n-1 * n-2 ... 1
(check-expect (! 0) 1)
(check-expect (! 1) 1)
(check-expect (! 2) 2)
(check-expect (! 3) 6)
(check-expect (! 4) 24)

(define (! n)
  (cond
    [(zero? n) 1]
    [(positive? n)
     (mul n (! (sub1 n)))]))


; mul : Nat Nat -> Nat
; produces the product of n and m
(check-expect (mul 0 1) 0)
(check-expect (mul 0 100) 0)
(check-expect (mul 1 5) 5)
(check-expect (mul 2 5) 10)
(check-expect (mul 3 5) 15)
(check-expect (mul 3 0) 0)

(define (mul n m)
  (cond
    [(zero? n) 0]
    [(positive? n)
     (add m (mul (sub1 n) m))]))


; add : Nat Nat -> Nat
; produces the sum of n and m
(check-expect (add 0 1) 1)
(check-expect (add 0 100) 100)
(check-expect (add 1 5) 6)
(check-expect (add 2 5) 7)
(check-expect (add 3 5) 8)
(check-expect (add 3 0) 3)

(define (add n m)
  (cond
    [(zero? n) m]
    [(positive? n)
     (add1 (add (sub1 n) m))]))




;                                                           
; Now lets do something more radical. Lets change how we actually
; REPRESENT the natural numbers.
; 
; Let's pretend that we have been given a version of DrRacket that
; does not have numbers as primitive data. We can't write values
; like 1 or 2, and we don't have primitives like + and -. So we
; are like cavemen, but with laptops.
; 
; Why should we play such a crazy game?
; 
;  - It's kind of fun.
;  - It will help us see that that ALL data is subject to
;    interpretation. And that there is no such thing as
;    primitive data really, there is just data which we
;    interpret as being primitive.
;  - It shows powerfully that not all data definitions 
;    are equally good.
; 
; In the code below we use UPPERCASE names for the new kind
; of naturals and functions that operate on them...
; 
; The basic idea is that while we don't have numbers we
; do have lists. So we will invent a "tally mark" natural
; number notation (http://en.wikipedia.org/wiki/Tally_marks).
; 
; 


;; DATA DEFINITION

; NAT is one of:
;  - empty
;  - (cons "!" NAT)
; interp. empty is 0, (cons "!" empty) is 1 and so on,
;         so a list of n "!"s represents n.

(define ZERO  empty)              ;for convenience, we give
(define ONE   (cons "!" empty))   ;these examples good names
(define TWO   (cons "!" ONE))
(define THREE (cons "!" TWO))
(define FOUR  (cons "!" THREE))
(define FIVE  (cons "!" FOUR))
(define SIX   (cons "!" FIVE))
(define SEVEN (cons "!" SIX))
(define EIGHT (cons "!" SEVEN))
(define NINE  (cons "!" EIGHT))
(define TEN  (cons "!" NINE))
(define ELEVEN  (cons "!" TEN))

;; TO MAKE OUR TEMPLATE WORK, and simplify other code, we
;; explicitly define versions of a constructor, predicate,
;; and selector function. Because these functions are very familiar, 
;; their tests are deferred to the end of the file.

(define (ZERO? n) (empty? n))    ; Any -> Boolean
(define (POSITIVE? n) (cons? n)) ; Any -> Boolean
(define (ADD1  n) (cons "!" n))  ; NAT -> NAT
(define (SUB1  n) (rest n))      ; NAT -> NAT

;; TEMPLATE

#;
(define (NAT-func n)
  (cond [(ZERO? n) (...)]
        [(POSITIVE? n)
         (... (NAT-func (SUB1 n)) ...)]))


;                                                           
; FUNCTIONS ON NAT
; 
; ; BOXES : NAT -> Image
; ; produce n nested boxes with dot inside
;   (boxes 0)  produces .
;   (boxes 1)  produces .
;   (boxes 4)  produces .
; 
; 
; ; !! : NAT -> NAT
; ; produces n * n-1 * n-2 ... 1
;   
; ; MUL : NAT NAT -> NAT
; ; produces the product of n and m
;   
; ; ADD : NAT NAT -> NAT
; ; produces the sum of n and m



; !! : Nat -> Nat
; produces n * n-1 * n-2 ... 1
(check-expect (!! ZERO) ONE)
(check-expect (!! ONE) ONE)
(check-expect (!! TWO) TWO)
(check-expect (!! THREE) SIX)

(define (!! n)
  (cond
    [(ZERO? n) ONE]
    [(POSITIVE? n)
     (MUL n (!! (SUB1 n)))]))


; MUL : Nat Nat -> Nat
; produces the product of n and m
(check-expect (MUL ZERO ONE)    ZERO)
(check-expect (MUL ZERO ELEVEN) ZERO)
(check-expect (MUL ONE FIVE)    FIVE)
(check-expect (MUL TWO FIVE)    TEN)
(check-expect (MUL THREE ZERO)  ZERO)

(define (MUL n m)
  (cond
    [(ZERO? n) ZERO]
    [(POSITIVE? n)
     (ADD m (MUL (SUB1 n) m))]))


; ADD : Nat Nat -> Nat
; produces the sum of n and m
(check-expect (ADD ZERO ONE) ONE)
(check-expect (ADD ZERO THREE) THREE)
(check-expect (ADD ONE FIVE) SIX)
(check-expect (ADD TWO FIVE) SEVEN)
(check-expect (ADD THREE FIVE) EIGHT)

(define (ADD n m)
  (cond
    [(ZERO? n) m]
    [(POSITIVE? n)
     (ADD1 (ADD (SUB1 n) m))]))


; NAT->number : NAT -> Number
; produces a Racket representation of the given NAT
(check-expect (NAT->number ZERO) 0)
(check-expect (NAT->number EIGHT) 8)

(define (NAT->number n)
  (length n))



;; TESTS FOR BASIC FUNCTIONS DEFINED ABOVE...

(check-expect (ZERO? ZERO) true)
(check-expect (ZERO? ONE)  false)

(check-expect (POSITIVE? ZERO) false)
(check-expect (POSITIVE? ONE)  true)

(check-expect (ADD1 ZERO) ONE)
(check-expect (ADD1 ONE)  TWO)

(check-expect (SUB1 ONE) ZERO)
(check-expect (SUB1 TWO) ONE)


; 
; So what's a number? Is it something like 2? Or something like
; (cons "!" (cons "!" empty))? Neither, both are NUMERALS, that
; just represent numbers. You've probably heard about the difference
; between numerals and numbers before. But it may not be until just
; now that you've really understood the difference. A numeral is
; a representation of a number. Numerals are data, we can operate
; on them.
;  
; Whenever we operate with numbers we know there will be some data,
; and an interpretation of that data as a number. But for all we
; know, the data could be anything. Strings, lists, magnetic
; fields, quantum states, or even "turtles all the way down"
; (http://en.wikipedia.org/wiki/Turtles_all_the_way_down).
; 
; We don't know, and we mostly don't need to know how DrRacket
; represents natural numbers. If you've programmed in C or Java, you
; might think you know. In that case, ask yourself whether the
; following expression should work in DrRacket:
; 
; (expt 2 1000)
; 
; Then run it. It does work, which means that integers in DrRacket
; are not represented the way they are in Java and C. Use Google
; to learn more about bignums.
; 
; But remember, the big takeaway point from this part of the
; lecture material is that you can design your own data representation
; for anything. You don't have to accept anything as truly primitive.
; As a program designer, you can represent any world you want - real
; or imaginary.
; 



;                                                           
; .
; 
; SOME MORE FUN...
; 


; fib : Nat -> Nat
; produces the n'th Fibonacci number, (fib 0) = 0, (fib 1) = 1
(check-expect (fib 0) 0)
(check-expect (fib 1) 1)
(check-expect (fib 2) 1)
(check-expect (fib 3) 2)
(check-expect (fib 4) 3)
(check-expect (fib 5) 5)

(define (fib n)
  (cond
    [(zero? n) 0]
    [(positive? n)
     (if (= n 1) 1
         (+ (fib (sub1 n))
            (fib (sub1 (sub1 n)))))])
  #;(fib-forward n 0 1))

; fib-forward : Nat Nat Nat
; produces the n'th Fibonacci number after f1, where f1 and 
; f2 are consecutive numbers in the Fibonacci sequence
(check-expect (fib-forward 0 3 5) 3)
(check-expect (fib-forward 1 3 5) 5)
(check-expect (fib-forward 2 3 5) 8)
(check-expect (fib-forward 2 5 8) 13)
(check-expect (fib-forward 1 8 13) 13)

(define (fib-forward n f1 f2)
  (cond
    [(zero? n) f1]
    [(positive? n)
     (fib-forward (sub1 n) f2 (+ f1 f2))]))



;                                                           
; Generating a list of numbers...
; 


; count-down-list : Nat -> (Listof Nat)
; produces a (list n n-1 n-2 ... 2 1 0)
(check-expect (count-down-list 0) (list 0))
(check-expect (count-down-list 5) (list 5 4 3 2 1 0))
(check-expect (count-down-list 6) (list 6 5 4 3 2 1 0))

(define (count-down-list n)
  (cond
    [(zero? n) (list 0)]
    [(positive? n)
     (cons n (count-down-list (sub1 n)))]))


;                                                           
; Generating the list the other way...
; 
; Implement  count-up-list,  which takes a natural number
; n and produces a list of numbers from 0 *up to* n, 
; inclusive.
; 


; count-up-list : Nat -> (Listof Nat)
; produces a (list 0 1 2 ... n)
(check-expect (count-up-list 0) (list 0))
(check-expect (count-up-list 5) (list 0 1 2 3 4 5))
(check-expect (count-up-list 6) (list 0 1 2 3 4 5 6))

; 
; (define (count-up-list n)
;   (cond
;     [(zero? n) (list 0)]
;     [(positive? n)
;      (... n (count-up-list (sub1 n)))]))   
; ;; uh oh... can't cons onto result of the natural recursion. 
; ;; maybe use snoc, but we can try something else...
; 


(define (count-up-list n)
  (count-up-to-n-list n n))

; produces a (list n-d n-d+1 ... n) - i.e. d elements before n
(check-expect (count-up-to-n-list 4 10) (list 6 7 8 9 10))

(define (count-up-to-n-list d n)
  (cond
    [(zero? d) (list n)]
    [(positive? d)
     (cons (- n d) (count-up-to-n-list (sub1 d) n))]))


