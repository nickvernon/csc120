;; Nick Vernon & Orbelin Palacios
;; LECTURE 25 - 3/25/2015
;; PROCESSING MULTIPLE COMPLEX DATA


;  For the exercises in this file, use appropriate templates to 
;  develop the functions. Do not try to use abstract list
;  functions.


#|

Oftentimes, a function may consume two arguments (parameters), both
of which are complex types of data, especially those with a 
"one of" and self-reference in their data definition (like lists, or
natural numbers). When designing such functions, there are generally
three possible scenarios you may find yourself in:

 - First, one of the arguments may have to be treated as if
   it were atomic. In other words, it is simply "along for the ride."

 - Second, it is possible that the function must process the
   two arguments in lockstep (parallel). 

 - Finally, the function may need to process every possible
   combination of cases of the given data.
  
In these exercises, you will work through one example of each of the
possible scenarios above. The textbook reading linked on the schedule
page has an entire section devoted to this topic if you would like
to read it later.

|#



;  TASK 1.                                                      
; 
; (First scenario)
; 
; Implement "append-lists", which takes two lists of numbers and
; returns a list with all of the numbers from the first list 
; followed by all of the numbers from the second list.
; 
; In this function, the second parameter, lst2, is simply
; "along for the ride". The dominant parameter is lst1.
; So apply the template *only* to the lst1 parameter 
; in order to fill in the body. Use the examples provide
; to guide you as you fill in the template.
; 



;; append-lists : (Listof Number) (Listof Number) -> (Listof Number)
;; produce a list with all the numbers of lst1 followed by all the numbers of lst2

(check-expect (append-lists empty empty) 
              empty)
(check-expect (append-lists empty (list 1 3 5)) 
              (list 1 3 5))
(check-expect (append-lists (list 2 4 6) (list 1 3 5))
              (list 2 4 6 1 3 5))
(check-expect (append-lists (cons 0 (list 2 4 6)) (list 1 3 5))
              (cons 0 (list 2 4 6 1 3 5)))

(define (append-lists lst1 lst2)   ; stub
  (cond
    [(empty? lst1) lst2]
    [(cons? lst1) (cons (first lst1)
                       (append-lists (rest lst1) lst2))]))


;  NOTE: Sometimes, for this first scenario, you may need a 
;        helper function to further process the second 
;        list parameter. Nonetheless, in the main function, 
;        you focus on the dominant list and do not try to
;        deconstruct or analyze the second one.
; 
;  NOTE: There is already a built-in function named
;        "append" that does what your "append-lists" does.
;        It works for lists of anything.

;  TASK 2.                                                      
; 
; (Second scenario)
; 
; Implement "parallel-sum", which takes two lists of numbers
; (of the same length) and returns a list of pairwise sums.
; 
; In this case the parameters range over the same type 
; of values (both are lists) and must have the same 
; size (length). Since the two parameters have this 
; equal status and the purpose suggests that they are
; processed in a synchronized manner, you choose one parameter,
; organize the template around it (as far as the questions in
; the conditional), and then traverse the other list in a 
; parallel manner -- whereever you write (first lst1) in the
; ...'s of the template, also write (first lst2); 
; in the recursive call, apply it to both (rest lst1) and
; (rest lst2).
; 



;; parallel-sum : (Listof Number) (Listof Number) -> (Listof Number)
;; produces a list of pairwise sums of numbers from the given lists,
;; which must be of the same length

(check-expect (parallel-sum empty empty) empty)
(check-expect (parallel-sum (list 0 2 4) (list 1 3 5)) (list 1 5 9))

(define (parallel-sum lst1 lst2)    ; stub
  (cond
    [(empty? lst1) empty]
    [(cons? lst1) (cons (+ (first lst1) (first lst2))
                        (parallel-sum (rest lst1) (rest lst2)))]))



;  TASK 3.                                                      
; 
; (Third scenario)
; 
; Implement "merge-lists", which takes two *sorted* lists
; of numbers and produces a combined list that is also sorted.
; 
; In this case, there are four independent cases that must
; by handled by this function. One way to discover these cases
; is to arrange the conditions corresponding to each clause of
; the list data definition in a two-dimensional table. We'll
; call this type of table a:
; ;                          CROSS-PRODUCT OF TYPES TABLE
; 
;               | (empty? lst1)  |   (cons? lst1)
; --------------+----------------+---------------
;               |                |
; (empty? lst2) |      ...       |      ...
;               |                |
; --------------+----------------+---------------
;               |                |
; (cons? lst2)  |      ...       |      ...
;               |                |
; 
; Based on this, you would lay out a template for this function
; with *four* clauses in the conditional. Each clause should
; use an (and ... ...) expression to describe each of the four
; possible combinations in the table above. For example, the
; condition for the top left cell would be:
;    (and (empty? lst1) (empty? lst2))
; 
; Lay out a template for this function, then use the 
; examples to guide you as you fill it in.
; 




;; merge-lists : (Listof Number) (Listof Number) -> (Listof Number)
;; produce a combined sorted list of numbers from the two given
;;  lists of sorted numbers

(check-expect (merge-lists empty empty) empty)
(check-expect (merge-lists empty (list 0 4 6)) (list 0 4 6))
(check-expect (merge-lists (list 1 3 5) empty) (list 1 3 5))
(check-expect (merge-lists (list 1 3 5) (list 2 4 6))
              (list 1 2 3 4 5 6))
(check-expect (merge-lists (list 1 3 5) (list 0 2 4 6))
              (list 0 1 2 3 4 5 6))

(define (merge-lists lst1 lst2)
  (cond
    [(and (empty? lst1) (empty? lst2)) empty]
    [(and (empty? lst1) (cons? lst2)) lst2]
    [(and (cons? lst1) (empty? lst2)) lst1]
    [(and (cons? lst1) (cons? lst2)) 
          (if (= (first lst1) (first lst2))
                 (cons (first lst1)
                    (merge-lists (rest lst1) (rest lst2)))
          (if (> (first lst1) (first lst2))
                 (cons (first lst2)
                    (merge-lists lst1 (rest lst2)))
                 (cons (first lst1)
                    (merge-lists (rest lst1) lst2))))]))


; 
; NOTE: This last approach works even when the two parameters 
; are of two different types of data, for example:
;   a list and a natural number, or
;   a list and a tree (coming up soon...)
; 
; You can still build a similar two-dimensional table to
; help you figure out how to lay out the template. Produce
; examples for each one of the cells in the table - i.e.
; cover all possible combinations. Use those examples to guide  
; you as you fill in the function.
; 








;; ==============================================================
;; ==============================================================
;; ==============================================================
;; ==============================================================
;; ==============================================================


; 
; For the next several tasks, it is up to you to figure out which
; one of the three scenarios above applies. Make sure you work out
; sufficient examples to gain insight and help you fill in the 
; definitions.
; 



;; A 1String is a one-letter string

(define-struct pair (fst snd))
;; A Pair is (make-pair 1String 1String)
;; interp. a pair of letters, where the first matches up with the second


;  TASK 4. 
; 
;  Develop a function, "zip-letters", which consumes two lists of 
;  one-letter strings and produces a list of pairs where the 
;  corresponding letters are paired up.
; 
;  For example,
;     (zip-letters (list "a" "b") (list "c" "d"))
;  should produce
;     (list (make-pair "a" "c") (make-pair "b" "d"))
; 



;; zip-letters : (Listof 1String) (Listof 1String) -> (Listof Pair)
;; produces a list of pairs of the corresponding letters from each
;;  of the two given lists

(check-expect (zip-letters (list "a" "b") 
                           (list "c" "d"))  
                   (list (make-pair "a" "c") (make-pair "b" "d")))
(check-expect (zip-letters (list "m" "n") 
                           (list "h" "a"))  
                   (list (make-pair "m" "h") (make-pair "n" "a")))
(check-expect (zip-letters (list "c" "f" "g") 
                           (list "v" "e" "k"))  
                   (list (make-pair "c" "v") (make-pair "f" "e") (make-pair "g" "k")))

(define (zip-letters lstA lstB)    ; stub
  (cond
    [(empty? lstA) empty]
    [(cons? lstA) (cons (make-pair (first lstA) (first lstB))
                        (zip-letters (rest lstA) (rest lstB)))]))

;  TASK 5. 
; 
;  Develop a function, "replace-letters", which consumes a 
;  list of one-letter strings and a list of pairs and produces 
;  a list of one-letter strings where each letter in the given
;  list is replaced by the letters that it is matched up with
;  in the list of pairs. If a letter does not occur in the first
;  element of any pair, keep the letter as is.
; 
;  For example, 
;      (replace-letters (list "a" "a" "!" "b")
;                       (list (make-pair "a" "c") (make-pair "b" "d")))
;  should produce
;      (list "c" "c" "!" "d")
; 



;; replace-letters : (Listof 1String) (Listof Pair) -> (Listof 1String)
;; replace every letter in a-lol with the letter it is matched up with
;;   in the list of pairs, unless it does not occur in a pair, in which
;;   case the letter is retained as is.

(check-expect (replace-letters empty empty)
     empty)
(check-expect (replace-letters (list "a" "a" "!" "b")
                      (list (make-pair "a" "c") (make-pair "b" "d")))
     (list "c" "c" "!" "d"))

(define (replace-letters a-lol a-lop)    ; stub
  (cond
    [(and (empty? a-lol) (empty? a-lop)) empty]
    [(and (empty? a-lol) (cons? a-lop)) empty]
    [(and (cons? a-lol) (empty? a-lop)) a-lol]
    [else (cons (find-and-replace (first a-lol) a-lop)
                                (replace-letters (rest a-lol) a-lop))]))

;; find-and-replace : String (Listof Pairs) -> String    ; HELPER FUNCTION
;; replace each letter in a-lol with the letters it is matched up with
;; in the given pair, unless it does not occur in a pair, in which
;; case the letter is retained as is.

(check-expect (find-and-replace "a"
                       (list (make-pair "a" "c") (make-pair "b" "d")))
     "c")

(define (find-and-replace s a-lop)
  (cond
    [(empty? a-lop) s]
    [(cons? a-lop) (if (equal? (pair-fst (first a-lop)) s)
                       (pair-snd (first a-lop))
                       (find-and-replace s (rest a-lop)))]))


; 
;  Now let's put your functions together to have some fun...
; 
;  Uncomment the function definition below. Can you understand how it
;  works? Look up any functions you're not familiar with, like 
;  explode, implode, reverse.
; 
;  Use this program to write your emails/tweets/facebook posts
;  for today! Try:
; 
;    > (upside-down "I learned to type upside down in CSC120!")
; 


(define ALPHABET "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz?!,’._()[]{}<>;0123456789")
(define ┴Ǝq∀HԀ˥∀ "∀qƆpƎℲפHIſʞ˥WNOԀQɹS┴∩ΛMX⅄Zɐqɔpǝɟƃɥıɾʞןɯuodbɹsʇnʌʍxʎz¿¡’,˙‾)(][}{><؛0ƖᄅƐㄣϛ9ㄥ86")


;; upside-down : String -> String
;; turn a string upside down

(check-expect (upside-down "Look ma! No hands!") "¡spuɐɥ oN ¡ɐɯ ʞoo˥")

(define (upside-down s)
  (implode (reverse (replace-letters (explode s)
                                     (zip-letters (explode ALPHABET) 
                                                  (explode ┴Ǝq∀HԀ˥∀))))))






;; ==============================================================
;; ==============================================================
;; ==============================================================
;; ==============================================================
;; ==============================================================


;  
; ;                                                          
; ;                                                          
; ;    ;;;;           ;       ;                        ;;;   
; ;    ;  ;           ;                                  ;   
; ;   ;    ; ;;;;   ;;;;;   ;;;    ;;;   ; ;;   ;;;;     ;   
; ;   ;    ; ;; ;;    ;       ;   ;; ;;  ;;  ;      ;    ;   
; ;   ;    ; ;   ;    ;       ;   ;   ;  ;   ;      ;    ;   
; ;   ;    ; ;   ;    ;       ;   ;   ;  ;   ;   ;;;;    ;   
; ;   ;    ; ;   ;    ;       ;   ;   ;  ;   ;  ;   ;    ;   
; ;    ;  ;  ;; ;;    ;       ;   ;; ;;  ;   ;  ;   ;    ;   
; ;    ;;;;  ;;;;     ;;;   ;;;;;  ;;;   ;   ;   ;;;;     ;; 
; ;          ;                                               
; ;          ;                                               
; ;          ;                                               
; 



;  For this one, make a cross product of types table based on
;  the data definition for natural numbers and for lists.
; 
;  Use (error "... msg ...") to signal an error situation -
;  like if there are no elements at all in the list.
; 


;; list-pick : Nat (Listof X) -> X
;; produces the i'th element of the given list, where the 
;;  first element is indexed with 0

(check-expect (list-pick 0 (list 0 1 2 3)) 0)

(define (list-pick i lst)   ; stub
  0)




;  Design "cross". The function consumes a list of strings
;  and a list of numbers and produces all possible ordered 
;  pairs of symbols and numbers. That is, when given
;  (list "a" "b" "c") and (list 1 2), the expected result is 
;  (list (list "a" 1) (list "a" 2) (list "b" 1) (list "b" 2)
;        (list "c" 1) (list "c" 2)).


;; cross : (Listof String) (Listof Number) -> (Listof (list String Number))
;; ...

(check-expect (cross empty empty) empty)

(define (cross lst1 lst2)    ; stub
  empty)



